[Back](../README.md)
***
# JS and Browser
Есть объект window, который хранит в себе следующие вещи:

BOM - Browser Object Model, объектая модель браузера, которая позволяет работать с navigator, screen, location, history, localStorage, sessionStorage, .fetch().

DOM - Document Object Model.


### Обработка события
Через вызов функции в html:
```html
<body>
    <button onclick="buttonClick()"></button>
    <script src="code.js"></script>
</body>
```

Через вызов обработчика в скрипте:

```js
const button = document.querySelector(".//button[1]")
button.onclick = () => {
    // do smth
}

// или

button.onclick = functionName
```

На один тип события одного элемента можно повесить только один обработчик.

Через вызов метода добавления листенера для события:
```js
const button = document.querySelector(".//button[1]")

button.addEventListener('click', (event) => {})
button.removeEventListener('click', () => {}) // для удаления обработчика надо передавать не стрелочную функцию, а ссылку на функцию
```

event - уникальный для каждого события объект, который содержит атрибуты, которые свойственны именно этому событию. В event.target содержится ссылка на элемент, на котором произошло событие.

**Всплытие события (bubbling)** - важный момент, касающийся реализации обработки сработавших событий. Если есть несколько вложенных элементов,
по клике на внутреннее сначала выполнится его обработчик события, а затем по цепочке "снизу-вверх" будут выполняться обработчики событий 
родителей этого элемента, пока элемент не "всплывет" до document. 

При этом event.target всегда будет иметь ссылку на элемент-триггер, даже
если сработал обработчик родителя элемента, а вот event.currentTarget будет ссылаться на родителя. Также можно обращаться к текущему элементу
через this.

Можно заблокировать всплытие события с помощью stopPropagation():

```js
const button = document.querySelector(".//button[1]")

button.addEventListener('click', (event) => {
    // do smth
    event.stopPropagation() // блокирует выполнение других обработчиков родителей элемента
    event.stopImmediatePropagation() // блокирует выполнение других обработчиков событий на этом же элементе
})
```

События focus и blur не всплывают от элемента вверх по иерархии. Если нужно перехватить их на уровне document, то можно
использовать события focusin и focusout. Важный момент: состояние фокуса возникает только на интерактивных типах элементов.
Чтобы добавить неинтерактивный элемент в список элементов, которые можно взять в фокус, надо добавлять в html-разметке
свойство tabindex="0", где число, присваемое ему, должно быть >=0 (число указывает номер элемента, а при 0 браузер сам определит номер позиции элемента).

***
[Next](api.md)